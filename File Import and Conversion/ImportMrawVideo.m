function [ImageInfo, ImageMatrix] = ImportMrawVideo(fn,saveall,savefirstN,smallNfrm,CompressData)
%% Comments
%
% This function is designed to import a .mraw file generated by Photron's
% PFV software and directly convert it to MATLAB's compressed .mat format.
% The function takes as inputs
%
% function [ImageInfo, ImageMatrix] = ImportMrawVideo(fn,saveall,savefirstN,smallNfrm,CompressData)
%
%   where BITDEPTH is the integer number of bits used to store each pixel
%   (for example, BITDEPTH = 12 for the SA5 camera when the image is saved
%   at the bit depth of the sensor).  M and N are the pixel resolution of
%   the image, where M is the number of horizontal rows and N the number of
%   vertical columns.  Finally, FILENAME is a string containing the full
%   path to the .mraw file to be imported, including the .mraw extension
%   at the end.
%
%   The default behavior is to save a new file in the same location as the
%   original and with the same name, but with the MATLAB data filename
%   extension .mat.  Conversion times from .mraw to .mat vary linearly with
%   file size, i.e., elapsed time is proportional to M x N x (number of
%   frames).  This contrasts with a more typical .mraw --> .tif conversion
%   in PFV, followed by a .tif --> .mat conversion in MATLAB, which is
%   significantly slowed by PFV's .tif file writing routine, which takes
%   an elapsed time proportional to the square of the file size.
%
%   Copyright 2011, Michael McDonald
%
% Sample timings for a 140,000 frame 192x192 pixel video:
% (12-bit, M=N=192, P = 140000)
%   Binary import to memory: 17 min
%   Save to .mat: 10 min
% Gives 30% size reduction.
% To load resulting .mat file: 2 min
% To take mean image: 6.5 sec

%% For manual execution with hard-coded filename, bit depth and resolution

debug = 0;
if nargin==0
    [file, path] = uigetfile('.mraw');
    fn = fullfile(path,file);    %     load(fn)
    savefirstN = 1;
    smallNfrm = 100;
    close all
    saveall = 0;
    CompressData = 0;
end
if nargin==1
    % Switch to save a subset consisting of the first few video frames as a
    % small file for quick low-fidelity analysis and tests, in addition to
    % saving the full video
    savefirstN = 0;
        % Number of frames to save from full video
    smallNfrm = 100;
end
disp(sprintf('\r'))

if CompressData
    FileInfo.CompressionVersion = '1.1';
    FileInfo.DeleteMRAW = 0;
else
    FileInfo.CompressionVersion = 'none';
    FileInfo.DeleteMRAW = 0;
end


%% Initialize / Preallocate

tic

% Remove .mat or .mraw or any file extension
fn = RemoveFileExtension(fn);
cih_filename = [fn '.cih'];
mraw_filename = [fn '.mraw'];
CompressFilename = [fn '_Compress'];


% Get image file info from Photron .cih camera information header file
ImageInfo = ReadFastcamHeader(cih_filename);
bitdepth = ImageInfo.BitDepth;
M = ImageInfo.ImageHeight;
N = ImageInfo.ImageWidth;
P = ImageInfo.NumFrames;


% Optional: check file size info using directory commands
% fileInfo = dir(mraw_filename);
% fileSize = fileInfo.bytes;

disp(['Video file with ' num2str(P) ' images discovered, importing...'])

%% Read in MRAW data to MATLAB matrix

% Initialize ImageMatrix variable as zeros in 'int16' format
ImageMatrix = zeros(M,N,P,'int16');

% Read in camera data in bitN form and spit it out as 16-bit data
fid = fopen(mraw_filename,'r','b');    % file is saved as a big-endian, hence the 'b'

% One loop iteration per video frame
convertstring = ['ubit' num2str(bitdepth) '=>int16'];
for i=1:P
    if mod(i,round(P/4)) == 0; disp(num2str(i)); end
    x = fread(fid, [N,M], convertstring);
    ImageMatrix(:,:,i) = x';
end
fclose(fid);

toc; tic

if debug; dum = ImageMatrix; end

%% Save First N Frames

% Save a subset of the video in a smaller file, if the input length of the
% shorter file (smallNfrm) is less than the length of the full file
if savefirstN && smallNfrm < size(ImageMatrix,3)
    % store compression version for full image matrix
    dum = FileInfo.CompressionVersion;
    FileInfo.CompressionVersion = 'none';
    % Create file name to save first N frames separately
    smallfn = [fn '_small.mat'];
    % Store first N images in new matrix
    ImageMatrixSmall = ImageMatrix(:,:,1:smallNfrm);
    % Compute mean image (double floating precision)
    MeanImage = mean(ImageMatrix,3);
    % Save to specified file
    save(smallfn,'ImageInfo','FileInfo','MeanImage','ImageMatrixSmall','-v7.3')
    % Restore compression version for saving large file
    FileInfo.CompressionVersion = dum;
    clear dum
end

%% Save Data, If Required Perform Data Compression

if saveall
        
    if CompressData
        MeanImage = int16(mean(ImageMatrix,3));
        FrameIntensity = sum(sum(ImageMatrix));
        Normalization = mean(FrameIntensity(:))/FrameIntensity;
        ImageMatrixAC = zeros(size(ImageMatrix),'int16');
        
        % Subtract off normalized mean image to create AC-coupled image matrix
        %   -- this step subtracts off a brighter mean image from brighter
        %   images (cases where normalization(i) < 1) and vice versa
        for i=1:size(ImageMatrix,3)
            % Doing it this way preserves integer mathematics reversibility
            ImageMatrixAC(:,:,i) = ImageMatrix(:,:,i) - MeanImage/Normalization(i);
            
            % Doing it this way introduces reconstruction errors:
            % ImageMatrixAC(:,:,i) = ImageMatrix(:,:,i)*Normalization(i) - MeanImage;
        end
        
        % Do the data compression using Haar transforms over image rows and columns
        % (but not in the third dimension, i.e., time)
        [Final8BitSparsity,ImageMatrixAC] = VideoCompress_v1p1(ImageMatrixAC);
        
        % Store indices and excess values of each pixel outside the int8 range
        if Final8BitSparsity<0.01
            LoIndices = sparse(ImageMatrixAC(:)<intmin('int8'));
            HiIndices = sparse(ImageMatrixAC(:)>intmax('int8'));
        else
            LoIndices = single(find(ImageMatrixAC(:)<intmin('int8')));
            HiIndices = single(find(ImageMatrixAC(:)>intmax('int8')));
        end
        LoValues = ImageMatrixAC(LoIndices) - int16(intmin('int8'));
        HiValues = ImageMatrixAC(HiIndices) - int16(intmax('int8'));
        
        % Now store image matrix into 8-bit 'int8' format since the larger values
        % have been removed and stored elsewhere
        ImageMatrixAC = int8(ImageMatrixAC);
        
        % Save compressed image data
        save(CompressFilename,'ImageInfo','FileInfo','ImageMatrixAC','MeanImage','Normalization',...
            'LoIndices','HiIndices','LoValues','HiValues','-v7.3')
   else
        % Save uncompressed image data
        save(fn,'ImageInfo','FileInfo','ImageMatrix','-v7.3')      
    end
end
toc

return
%% Test reconstruction

if debug
    ImageMatrix = zeros(M,N,P,'int16');
    ImageMatrixAC = int16(ImageMatrixAC);
    ImageMatrixAC(LoIndices) = ImageMatrixAC(LoIndices) + LoValues;
    ImageMatrixAC(HiIndices) = ImageMatrixAC(HiIndices) + HiValues;
    for i=1:size(ImageMatrix,3)
        ImageMatrix(:,:,i) = ImageMatrixAC(:,:,i) + MeanImage/Normalization(i);
    end
    sum(ImageMatrix(:)-dum(:))
end

%% Save small data subset if desired


% Test small subset reconstruction
if debug
    dum = dum(:,:,1:smallNfrm);
    ImageMatrix = zeros(M,N,smallNfrm,'int16');
    ImageMatrixAC = int16(ImageMatrixAC);
    ImageMatrixAC(LoIndices) = ImageMatrixAC(LoIndices) + LoValues;
    ImageMatrixAC(HiIndices) = ImageMatrixAC(HiIndices) + HiValues;
    for i=1:size(ImageMatrix,3)
        ImageMatrix(:,:,i) = ImageMatrixAC(:,:,i) + MeanImage/Normalization(i);
    end
    sum(ImageMatrix(:)-dum(:))
end
